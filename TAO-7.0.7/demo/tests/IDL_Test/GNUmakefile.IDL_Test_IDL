# -*- Makefile -*-
#----------------------------------------------------------------------------
#       GNU Makefile
#
# @file GNUmakefile.IDL_Test_IDL
#
# This file was automatically generated by MPC.  Any changes made directly to
# this file will be lost the next time it is generated.
#
#----------------------------------------------------------------------------
MAKEFILE         = GNUmakefile.IDL_Test_IDL
DEPENDENCY_FILE  = .depend.IDL_Test_IDL

IDL_DEPENDENCY_FILE1 = .depend.IDL_Test_IDL_Idl1
IDL_DEPENDENCY_FILE2 = .depend.IDL_Test_IDL_Idl2
IDL_DEPENDENCY_FILE3 = .depend.IDL_Test_IDL_Idl3
IDL_DEPENDENCY_FILE4 = .depend.IDL_Test_IDL_Idl4
IDL_DEPENDENCY_FILE5 = .depend.IDL_Test_IDL_Idl5
IDL_DEPENDENCY_FILE6 = .depend.IDL_Test_IDL_Idl6
IDL_DEPENDENCY_FILE7 = .depend.IDL_Test_IDL_Idl7
IDL_DEPENDENCY_FILE8 = .depend.IDL_Test_IDL_Idl8
IDL_DEPENDENCY_FILE9 = .depend.IDL_Test_IDL_Idl9
IDL_DEPENDENCY_FILE10 = .depend.IDL_Test_IDL_Idl10
IDL_DEPENDENCY_FILE11 = .depend.IDL_Test_IDL_Idl11
IDL_DEPENDENCY_FILE12 = .depend.IDL_Test_IDL_Idl12
IDL_DEPENDENCY_FILE13 = .depend.IDL_Test_IDL_Idl13
IDL_DEPENDENCY_FILE14 = .depend.IDL_Test_IDL_Idl14
IDL_DEPENDENCY_FILE15 = .depend.IDL_Test_IDL_Idl15
IDL_DEPENDENCY_FILE16 = .depend.IDL_Test_IDL_Idl16
IDL_DEPENDENCY_FILE17 = .depend.IDL_Test_IDL_Idl17
IDL_DEPENDENCY_FILE18 = .depend.IDL_Test_IDL_Idl18
IDL_DEPENDENCY_FILE19 = .depend.IDL_Test_IDL_Idl19
IDL_DEPENDENCY_FILE20 = .depend.IDL_Test_IDL_Idl20
IDL_DEPENDENCY_FILE21 = .depend.IDL_Test_IDL_Idl21
IDL_DEPENDENCY_FILE22 = .depend.IDL_Test_IDL_Idl22
IDL_DEPENDENCY_FILE23 = .depend.IDL_Test_IDL_Idl23
IDL_DEPENDENCY_FILE24 = .depend.IDL_Test_IDL_Idl24
IDL_DEPENDENCY_FILE25 = .depend.IDL_Test_IDL_Idl25
IDL_DEPENDENCY_FILE26 = .depend.IDL_Test_IDL_Idl26
IDL_DEPENDENCY_FILE27 = .depend.IDL_Test_IDL_Idl27
IDL_DEPENDENCY_FILE28 = .depend.IDL_Test_IDL_Idl28
IDL_DEPENDENCY_FILE29 = .depend.IDL_Test_IDL_Idl29
IDL_DEPENDENCY_FILE30 = .depend.IDL_Test_IDL_Idl30
IDL_DEPENDENCY_FILE31 = .depend.IDL_Test_IDL_Idl31
IDL_DEPENDENCY_FILE32 = .depend.IDL_Test_IDL_Idl32
IDL_DEPENDENCY_FILE33 = .depend.IDL_Test_IDL_Idl33
IDL_DEPENDENCY_FILE34 = .depend.IDL_Test_IDL_Idl34
IDL_DEPENDENCY_FILE35 = .depend.IDL_Test_IDL_Idl35
IDL_DEPENDENCY_FILE36 = .depend.IDL_Test_IDL_Idl36
IDL_DEPENDENCY_FILE37 = .depend.IDL_Test_IDL_Idl37
IDL_DEPENDENCY_FILE38 = .depend.IDL_Test_IDL_Idl38
IDL_DEPENDENCY_FILE39 = .depend.IDL_Test_IDL_Idl39
IDL_DEPENDENCY_FILE40 = .depend.IDL_Test_IDL_Idl40
IDL_DEPENDENCY_FILE41 = .depend.IDL_Test_IDL_Idl41
IDL_DEPENDENCY_FILE42 = .depend.IDL_Test_IDL_Idl42
IDL_DEPENDENCY_FILE43 = .depend.IDL_Test_IDL_Idl43
IDL_DEPENDENCY_FILE44 = .depend.IDL_Test_IDL_Idl44
IDL_DEPENDENCY_FILE45 = .depend.IDL_Test_IDL_Idl45
IDL_DEPENDENCY_FILE46 = .depend.IDL_Test_IDL_Idl46
IDL_DEPENDENCY_FILE47 = .depend.IDL_Test_IDL_Idl47
IDL_DEPENDENCY_FILE48 = .depend.IDL_Test_IDL_Idl48
IDL_DEPENDENCY_FILE49 = .depend.IDL_Test_IDL_Idl49
IDL_DEPENDENCY_FILE50 = .depend.IDL_Test_IDL_Idl50
IDL_DEPENDENCY_FILE51 = .depend.IDL_Test_IDL_Idl51
IDL_DEPENDENCY_FILE52 = .depend.IDL_Test_IDL_Idl52
IDL_DEPENDENCY_FILE53 = .depend.IDL_Test_IDL_Idl53
IDL_DEPENDENCY_FILE54 = .depend.IDL_Test_IDL_Idl54
IDL_DEPENDENCY_FILE55 = .depend.IDL_Test_IDL_Idl55
IDL_DEPENDENCY_FILE56 = .depend.IDL_Test_IDL_Idl56
IDL_DEPENDENCY_FILE57 = .depend.IDL_Test_IDL_Idl57
IDL_DEPENDENCY_FILE58 = .depend.IDL_Test_IDL_Idl58

IDL_DEPENDENCY_FILES += \
	.depend.IDL_Test_IDL_Idl1 \
	.depend.IDL_Test_IDL_Idl2 \
	.depend.IDL_Test_IDL_Idl3 \
	.depend.IDL_Test_IDL_Idl4 \
	.depend.IDL_Test_IDL_Idl5 \
	.depend.IDL_Test_IDL_Idl6 \
	.depend.IDL_Test_IDL_Idl7 \
	.depend.IDL_Test_IDL_Idl8 \
	.depend.IDL_Test_IDL_Idl9 \
	.depend.IDL_Test_IDL_Idl10 \
	.depend.IDL_Test_IDL_Idl11 \
	.depend.IDL_Test_IDL_Idl12 \
	.depend.IDL_Test_IDL_Idl13 \
	.depend.IDL_Test_IDL_Idl14 \
	.depend.IDL_Test_IDL_Idl15 \
	.depend.IDL_Test_IDL_Idl16 \
	.depend.IDL_Test_IDL_Idl17 \
	.depend.IDL_Test_IDL_Idl18 \
	.depend.IDL_Test_IDL_Idl19 \
	.depend.IDL_Test_IDL_Idl20 \
	.depend.IDL_Test_IDL_Idl21 \
	.depend.IDL_Test_IDL_Idl22 \
	.depend.IDL_Test_IDL_Idl23 \
	.depend.IDL_Test_IDL_Idl24 \
	.depend.IDL_Test_IDL_Idl25 \
	.depend.IDL_Test_IDL_Idl26 \
	.depend.IDL_Test_IDL_Idl27 \
	.depend.IDL_Test_IDL_Idl28 \
	.depend.IDL_Test_IDL_Idl29 \
	.depend.IDL_Test_IDL_Idl30 \
	.depend.IDL_Test_IDL_Idl31 \
	.depend.IDL_Test_IDL_Idl32 \
	.depend.IDL_Test_IDL_Idl33 \
	.depend.IDL_Test_IDL_Idl34 \
	.depend.IDL_Test_IDL_Idl35 \
	.depend.IDL_Test_IDL_Idl36 \
	.depend.IDL_Test_IDL_Idl37 \
	.depend.IDL_Test_IDL_Idl38 \
	.depend.IDL_Test_IDL_Idl39 \
	.depend.IDL_Test_IDL_Idl40 \
	.depend.IDL_Test_IDL_Idl41 \
	.depend.IDL_Test_IDL_Idl42 \
	.depend.IDL_Test_IDL_Idl43 \
	.depend.IDL_Test_IDL_Idl44 \
	.depend.IDL_Test_IDL_Idl45 \
	.depend.IDL_Test_IDL_Idl46 \
	.depend.IDL_Test_IDL_Idl47 \
	.depend.IDL_Test_IDL_Idl48 \
	.depend.IDL_Test_IDL_Idl49 \
	.depend.IDL_Test_IDL_Idl50 \
	.depend.IDL_Test_IDL_Idl51 \
	.depend.IDL_Test_IDL_Idl52 \
	.depend.IDL_Test_IDL_Idl53 \
	.depend.IDL_Test_IDL_Idl54 \
	.depend.IDL_Test_IDL_Idl55 \
	.depend.IDL_Test_IDL_Idl56 \
	.depend.IDL_Test_IDL_Idl57 \
	.depend.IDL_Test_IDL_Idl58

LIB_PREFIX      ?= lib

FILES = \

IDL_DEPS_FLAGS1 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -Gxhst
IDL_DEPS1 = attribute.idl

IDL_DEPS_FLAGS2 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS2 = array.idl

IDL_DEPS_FLAGS3 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS3 = Bug_2350_Regression.idl

IDL_DEPS_FLAGS4 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS4 = Bug_2577_Regression.idl

IDL_DEPS_FLAGS5 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS5 = Bug_2582_Regression.idl

IDL_DEPS_FLAGS6 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS6 = Bug_2583_Regression.idl

IDL_DEPS_FLAGS7 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS7 = Bug_2616_Regression.idl

IDL_DEPS_FLAGS8 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS8 = Bug_2619_Regression.idl

IDL_DEPS_FLAGS9 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS9 = Bug_3243_Regression.idl

IDL_DEPS_FLAGS10 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS10 = Bug_3312_Regression.idl

IDL_DEPS_FLAGS11 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS11 = Bug_3819_Regression.idl

IDL_DEPS_FLAGS12 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS12 = Bug_3821_Regression.idl

IDL_DEPS_FLAGS13 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS13 = expressions.idl

IDL_DEPS_FLAGS14 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS14 = full.idl

IDL_DEPS_FLAGS15 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS15 = fwd.idl

IDL_DEPS_FLAGS16 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS16 = gperf.idl

IDL_DEPS_FLAGS17 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS17 = interface.idl

IDL_DEPS_FLAGS18 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS18 = nested_scope.idl

IDL_DEPS_FLAGS19 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS19 = keywords.idl

IDL_DEPS_FLAGS20 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS20 = old_constants.idl

IDL_DEPS_FLAGS21 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS21 = simple.idl

IDL_DEPS_FLAGS22 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS22 = simple2.idl

IDL_DEPS_FLAGS23 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS23 = old_array.idl

IDL_DEPS_FLAGS24 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS24 = old_sequence.idl

IDL_DEPS_FLAGS25 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS25 = old_struct.idl

IDL_DEPS_FLAGS26 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS26 = old_union.idl

IDL_DEPS_FLAGS27 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS27 = old_union2.idl

IDL_DEPS_FLAGS28 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS28 = params.idl

IDL_DEPS_FLAGS29 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS29 = reopened_modules.idl

IDL_DEPS_FLAGS30 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS30 = sequence.idl

IDL_DEPS_FLAGS31 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS31 = struct.idl

IDL_DEPS_FLAGS32 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS32 = string_value.idl

IDL_DEPS_FLAGS33 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS33 = reopen_include1.idl

IDL_DEPS_FLAGS34 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS34 = reopen_include2.idl

IDL_DEPS_FLAGS35 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS35 = typeprefix.idl

IDL_DEPS_FLAGS36 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS36 = union.idl

IDL_DEPS_FLAGS37 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS37 = enum_in_struct.idl

IDL_DEPS_FLAGS38 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS38 = array_anonymous.idl

IDL_DEPS_FLAGS39 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS39 = array_anon_nested.idl

IDL_DEPS_FLAGS40 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS40 = included.idl

IDL_DEPS_FLAGS41 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS41 = including.idl

IDL_DEPS_FLAGS42 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS42 = sequence_anonymous.idl

IDL_DEPS_FLAGS43 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS43 = union_anonymous.idl

IDL_DEPS_FLAGS44 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS44 = anyunion.idl

IDL_DEPS_FLAGS45 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS45 = valuetype.idl

IDL_DEPS_FLAGS46 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as
IDL_DEPS46 = anonymous.idl

IDL_DEPS_FLAGS47 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as
IDL_DEPS47 = dif2.idl

IDL_DEPS_FLAGS48 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS48 = array_only.idl

IDL_DEPS_FLAGS49 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS49 = constants.idl

IDL_DEPS_FLAGS50 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS50 = generic_object.idl

IDL_DEPS_FLAGS51 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS51 = inherit.idl

IDL_DEPS_FLAGS52 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS52 = module.idl

IDL_DEPS_FLAGS53 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS53 = primtypes.idl

IDL_DEPS_FLAGS54 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS54 = pragma.idl

IDL_DEPS_FLAGS55 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS55 = repo_id_mod.idl

IDL_DEPS_FLAGS56 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS56 = typedef.idl

IDL_DEPS_FLAGS57 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS57 = typecode.idl

IDL_DEPS_FLAGS58 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd loader_const.idl
IDL_DEPS58 = PEMNaming.idl



LIBPATHS := . "../../../lib"

#----------------------------------------------------------------------------
#       Include macros and targets
#----------------------------------------------------------------------------
TAO_IDL = ../../../bin/tao_idl
TAO_IDL_DEP = ../../../bin/tao_idl$(EXEEXT)
TAO_IDLFLAGS = -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I ../..$(if $(ARCH), -g $(call ADD_QUOTE,$(call ADD_ARCH,$(ACE_ROOT)/bin/ace_gperf)))

PRJ_TYPE = library

COLLAPSE_SLASHES = $(if $(findstring //,$(1)),$(call COLLAPSE_SLASHES,$(subst //,/,$(1))),$(1))
INSLIB ?= $(call COLLAPSE_SLASHES,.)
ifeq ($(INSLIB),.)
  ifeq ($(CURDIR),)
    ifeq ($(PWD),)
      PWD=$(shell pwd)
    endif
  else
    PWD=$(CURDIR)
  endif
  INSLIB = $(PWD)
endif
OUTPUT_DIRECTORY = $(INSLIB)

include $(ACE_ROOT)/include/makeinclude/wrapper_macros.GNU

include $(TAO_ROOT)/rules.tao.GNU


GNUACE_PROJECT_VERSION ?= $(ACE_VERSION)

# To build multiple targets in the same directory on AIX, it works
# best to have a template directory per project.
# The compiler/linker isn't too smart about instantiating templates...
ifdef TEMPINCDIR
TEMPINCDIR := $(TEMPINCDIR)/IDL_Test_IDL
all: $(TEMPINCDIR)
endif

ifneq ($(OUTPUT_DIRECTORY),)
.PHONY: create_output_directory.local
all: create_output_directory.local
create_output_directory.local:
	-@$(MKDIR) "$(OUTPUT_DIRECTORY)" $(ACE_NUL_STDERR)
endif

LIBCHECK = 1
ifeq ($(corba_messaging),1)
ifneq ($(LIBCHECK), 1)
  all: lib_warning
endif
else
  all: require_warning
endif

ifeq ($(corba_messaging),1)
else
  all: require_warning
endif

include $(ACE_ROOT)/include/makeinclude/macros.GNU
include $(ACE_ROOT)/include/makeinclude/rules.common.GNU
include $(ACE_ROOT)/include/makeinclude/rules.nonested.GNU
include $(ACE_ROOT)/include/makeinclude/rules.local.GNU
ifeq ($(VXWORKSLINK),1)
include $(TGT_DIR)/h/make/rules.$(PRJ_TYPE)
endif

ifeq ($(VXWORKSLINK),1)
LDLIBPATH     = -L. -L../../../lib $(if $(android_abi),-llog)
else
LDFLAGS      += -L. $(if $(ARCH),-L./$(ARCH)) -L../../../lib $(if $(ARCH),-L../../../lib/$(ARCH)) $(if $(android_abi),-llog)
endif
CPPFLAGS     += -I../../.. -I../..
ifeq ($(static_libs),1)
  CPPFLAGS += -DACE_AS_STATIC_LIBS -DTAO_AS_STATIC_LIBS
endif

#----------------------------------------------------------------------------
#       Local targets
#----------------------------------------------------------------------------
.PHONY: lib_warning
lib_warning:
	@echo IDL_Test_IDL will not be built due to the following missing library: $(LIBCHECK) >&2

ifneq ($(corba_messaging),1)
requires_disabled_macros += corba_messaging
endif
.PHONY: require_warning
require_warning:
	@echo IDL_Test_IDL will not be built due to the following disabled make macros: $(requires_disabled_macros)>&2

## Some OS's have /bin/test others only have /usr/bin/test
ifeq ($(wildcard /bin/test), /bin/test)
  TEST_EXE = /bin/test
else
ifeq ($(wildcard /usr/bin/test), /usr/bin/test)
  TEST_EXE = /usr/bin/test
endif
endif

SPACE = $(should_be_unset) $(should_be_unset)
export DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export SHLIB_PATH        := $(SHLIB_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export LIBPATH           := $(LIBPATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export PATH              := $(PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))

GENERATED_DIRTY += attributeC.inl attributeS_T.cpp attributeS.h attributeC.h attributeS_T.h TAO_IDL_TEST_stub_export.h attributeS.cpp attributeC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "attribute.idl" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
attributeC.inl attributeS_T.cpp attributeS.h attributeC.h attributeS_T.h TAO_IDL_TEST_stub_export.h attributeS.cpp attributeC.cpp: attribute.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -Gxhst attribute.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
attributeC.inl attributeS_T.cpp attributeS.h attributeC.h attributeS_T.h TAO_IDL_TEST_stub_export.h attributeS.cpp attributeC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += arrayC.inl arrayS_T.cpp arrayS.h arrayC.h arrayS_T.h arrayS.cpp arrayC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array.idl" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
arrayC.inl arrayS_T.cpp arrayS.h arrayC.h arrayS_T.h arrayS.cpp arrayC.cpp: array.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd array.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
arrayC.inl arrayS_T.cpp arrayS.h arrayC.h arrayS_T.h arrayS.cpp arrayC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2350_RegressionC.inl Bug_2350_RegressionS_T.cpp Bug_2350_RegressionS.h Bug_2350_RegressionC.h Bug_2350_RegressionS_T.h Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2350_RegressionC.inl Bug_2350_RegressionS_T.cpp Bug_2350_RegressionS.h Bug_2350_RegressionC.h Bug_2350_RegressionS_T.h Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp: Bug_2350_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2350_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2350_RegressionC.inl Bug_2350_RegressionS_T.cpp Bug_2350_RegressionS.h Bug_2350_RegressionC.h Bug_2350_RegressionS_T.h Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2577_RegressionC.inl Bug_2577_RegressionS_T.cpp Bug_2577_RegressionS.h Bug_2577_RegressionC.h Bug_2577_RegressionS_T.h Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2577_RegressionC.inl Bug_2577_RegressionS_T.cpp Bug_2577_RegressionS.h Bug_2577_RegressionC.h Bug_2577_RegressionS_T.h Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp: Bug_2577_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2577_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2577_RegressionC.inl Bug_2577_RegressionS_T.cpp Bug_2577_RegressionS.h Bug_2577_RegressionC.h Bug_2577_RegressionS_T.h Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2582_RegressionC.inl Bug_2582_RegressionS_T.cpp Bug_2582_RegressionS.h Bug_2582_RegressionC.h Bug_2582_RegressionS_T.h Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2582_RegressionC.inl Bug_2582_RegressionS_T.cpp Bug_2582_RegressionS.h Bug_2582_RegressionC.h Bug_2582_RegressionS_T.h Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp: Bug_2582_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2582_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2582_RegressionC.inl Bug_2582_RegressionS_T.cpp Bug_2582_RegressionS.h Bug_2582_RegressionC.h Bug_2582_RegressionS_T.h Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2583_RegressionC.inl Bug_2583_RegressionS_T.cpp Bug_2583_RegressionS.h Bug_2583_RegressionC.h Bug_2583_RegressionS_T.h Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2583_RegressionC.inl Bug_2583_RegressionS_T.cpp Bug_2583_RegressionS.h Bug_2583_RegressionC.h Bug_2583_RegressionS_T.h Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp: Bug_2583_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2583_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2583_RegressionC.inl Bug_2583_RegressionS_T.cpp Bug_2583_RegressionS.h Bug_2583_RegressionC.h Bug_2583_RegressionS_T.h Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2616_RegressionC.inl Bug_2616_RegressionS_T.cpp Bug_2616_RegressionS.h Bug_2616_RegressionC.h Bug_2616_RegressionS_T.h Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2616_RegressionC.inl Bug_2616_RegressionS_T.cpp Bug_2616_RegressionS.h Bug_2616_RegressionC.h Bug_2616_RegressionS_T.h Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp: Bug_2616_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2616_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2616_RegressionC.inl Bug_2616_RegressionS_T.cpp Bug_2616_RegressionS.h Bug_2616_RegressionC.h Bug_2616_RegressionS_T.h Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2619_RegressionC.inl Bug_2619_RegressionS_T.cpp Bug_2619_RegressionS.h Bug_2619_RegressionC.h Bug_2619_RegressionS_T.h Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2619_RegressionC.inl Bug_2619_RegressionS_T.cpp Bug_2619_RegressionS.h Bug_2619_RegressionC.h Bug_2619_RegressionS_T.h Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp: Bug_2619_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2619_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2619_RegressionC.inl Bug_2619_RegressionS_T.cpp Bug_2619_RegressionS.h Bug_2619_RegressionC.h Bug_2619_RegressionS_T.h Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3243_RegressionC.inl Bug_3243_RegressionS_T.cpp Bug_3243_RegressionS.h Bug_3243_RegressionC.h Bug_3243_RegressionS_T.h Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3243_RegressionC.inl Bug_3243_RegressionS_T.cpp Bug_3243_RegressionS.h Bug_3243_RegressionC.h Bug_3243_RegressionS_T.h Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp: Bug_3243_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3243_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3243_RegressionC.inl Bug_3243_RegressionS_T.cpp Bug_3243_RegressionS.h Bug_3243_RegressionC.h Bug_3243_RegressionS_T.h Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3312_RegressionC.inl Bug_3312_RegressionS_T.cpp Bug_3312_RegressionS.h Bug_3312_RegressionC.h Bug_3312_RegressionS_T.h Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3312_RegressionC.inl Bug_3312_RegressionS_T.cpp Bug_3312_RegressionS.h Bug_3312_RegressionC.h Bug_3312_RegressionS_T.h Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp: Bug_3312_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3312_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3312_RegressionC.inl Bug_3312_RegressionS_T.cpp Bug_3312_RegressionS.h Bug_3312_RegressionC.h Bug_3312_RegressionS_T.h Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3819_RegressionC.inl Bug_3819_RegressionS_T.cpp Bug_3819_RegressionS.h Bug_3819_RegressionC.h Bug_3819_RegressionS_T.h Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3819_RegressionC.inl Bug_3819_RegressionS_T.cpp Bug_3819_RegressionS.h Bug_3819_RegressionC.h Bug_3819_RegressionS_T.h Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp: Bug_3819_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3819_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3819_RegressionC.inl Bug_3819_RegressionS_T.cpp Bug_3819_RegressionS.h Bug_3819_RegressionC.h Bug_3819_RegressionS_T.h Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3821_RegressionC.inl Bug_3821_RegressionS_T.cpp Bug_3821_RegressionS.h Bug_3821_RegressionC.h Bug_3821_RegressionS_T.h Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3821_RegressionC.inl Bug_3821_RegressionS_T.cpp Bug_3821_RegressionS.h Bug_3821_RegressionC.h Bug_3821_RegressionS_T.h Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp: Bug_3821_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3821_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3821_RegressionC.inl Bug_3821_RegressionS_T.cpp Bug_3821_RegressionS.h Bug_3821_RegressionC.h Bug_3821_RegressionS_T.h Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += expressionsC.inl expressionsS_T.cpp expressionsS.h expressionsC.h expressionsS_T.h expressionsS.cpp expressionsC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "expressions.idl" -nt "expressionsC.inl" 2> /dev/null || $(TEST_EXE) "expressions.idl" -nt "expressionsS_T.cpp" 2> /dev/null || $(TEST_EXE) "expressions.idl" -nt "expressionsS.h" 2> /dev/null || $(TEST_EXE) "expressions.idl" -nt "expressionsC.h" 2> /dev/null || $(TEST_EXE) "expressions.idl" -nt "expressionsS_T.h" 2> /dev/null || $(TEST_EXE) "expressions.idl" -nt "expressionsS.cpp" 2> /dev/null || $(TEST_EXE) "expressions.idl" -nt "expressionsC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "expressionsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "expressionsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "expressionsC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
expressionsC.inl expressionsS_T.cpp expressionsS.h expressionsC.h expressionsS_T.h expressionsS.cpp expressionsC.cpp: expressions.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd expressions.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
expressionsC.inl expressionsS_T.cpp expressionsS.h expressionsC.h expressionsS_T.h expressionsS.cpp expressionsC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += fullC.inl fullS_T.cpp fullS.h fullC.h fullS_T.h fullS.cpp fullC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "full.idl" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
fullC.inl fullS_T.cpp fullS.h fullC.h fullS_T.h fullS.cpp fullC.cpp: full.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd full.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
fullC.inl fullS_T.cpp fullS.h fullC.h fullS_T.h fullS.cpp fullC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += fwdC.inl fwdS_T.cpp fwdS.h fwdC.h fwdS_T.h fwdS.cpp fwdC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "fwd.idl" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
fwdC.inl fwdS_T.cpp fwdS.h fwdC.h fwdS_T.h fwdS.cpp fwdC.cpp: fwd.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd fwd.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
fwdC.inl fwdS_T.cpp fwdS.h fwdC.h fwdS_T.h fwdS.cpp fwdC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += gperfC.inl gperfS_T.cpp gperfS.h gperfC.h gperfS_T.h gperfS.cpp gperfC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "gperf.idl" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
gperfC.inl gperfS_T.cpp gperfS.h gperfC.h gperfS_T.h gperfS.cpp gperfC.cpp: gperf.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd gperf.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
gperfC.inl gperfS_T.cpp gperfS.h gperfC.h gperfS_T.h gperfS.cpp gperfC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += interfaceC.inl interfaceS_T.cpp interfaceS.h interfaceC.h interfaceS_T.h interfaceS.cpp interfaceC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "interface.idl" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
interfaceC.inl interfaceS_T.cpp interfaceS.h interfaceC.h interfaceS_T.h interfaceS.cpp interfaceC.cpp: interface.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd interface.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
interfaceC.inl interfaceS_T.cpp interfaceS.h interfaceC.h interfaceS_T.h interfaceS.cpp interfaceC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += nested_scopeC.inl nested_scopeS_T.cpp nested_scopeS.h nested_scopeC.h nested_scopeS_T.h nested_scopeS.cpp nested_scopeC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
nested_scopeC.inl nested_scopeS_T.cpp nested_scopeS.h nested_scopeC.h nested_scopeS_T.h nested_scopeS.cpp nested_scopeC.cpp: nested_scope.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd nested_scope.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
nested_scopeC.inl nested_scopeS_T.cpp nested_scopeS.h nested_scopeC.h nested_scopeS_T.h nested_scopeS.cpp nested_scopeC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += keywordsC.inl keywordsS_T.cpp keywordsS.h keywordsC.h keywordsS_T.h keywordsS.cpp keywordsC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "keywords.idl" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
keywordsC.inl keywordsS_T.cpp keywordsS.h keywordsC.h keywordsS_T.h keywordsS.cpp keywordsC.cpp: keywords.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd keywords.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
keywordsC.inl keywordsS_T.cpp keywordsS.h keywordsC.h keywordsS_T.h keywordsS.cpp keywordsC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_constantsC.inl old_constantsS_T.cpp old_constantsS.h old_constantsC.h old_constantsS_T.h old_constantsS.cpp old_constantsC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_constantsC.inl old_constantsS_T.cpp old_constantsS.h old_constantsC.h old_constantsS_T.h old_constantsS.cpp old_constantsC.cpp: old_constants.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_constants.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_constantsC.inl old_constantsS_T.cpp old_constantsS.h old_constantsC.h old_constantsS_T.h old_constantsS.cpp old_constantsC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += simpleC.inl simpleS_T.cpp simpleS.h simpleC.h simpleS_T.h simpleS.cpp simpleC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "simple.idl" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
simpleC.inl simpleS_T.cpp simpleS.h simpleC.h simpleS_T.h simpleS.cpp simpleC.cpp: simple.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd simple.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
simpleC.inl simpleS_T.cpp simpleS.h simpleC.h simpleS_T.h simpleS.cpp simpleC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += simple2C.inl simple2S_T.cpp simple2S.h simple2C.h simple2S_T.h simple2S.cpp simple2C.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "simple2.idl" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
simple2C.inl simple2S_T.cpp simple2S.h simple2C.h simple2S_T.h simple2S.cpp simple2C.cpp: simple2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd simple2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
simple2C.inl simple2S_T.cpp simple2S.h simple2C.h simple2S_T.h simple2S.cpp simple2C.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_arrayC.inl old_arrayS_T.cpp old_arrayS.h old_arrayC.h old_arrayS_T.h old_arrayS.cpp old_arrayC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_array.idl" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_arrayC.inl old_arrayS_T.cpp old_arrayS.h old_arrayC.h old_arrayS_T.h old_arrayS.cpp old_arrayC.cpp: old_array.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_array.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_arrayC.inl old_arrayS_T.cpp old_arrayS.h old_arrayC.h old_arrayS_T.h old_arrayS.cpp old_arrayC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_sequenceC.inl old_sequenceS_T.cpp old_sequenceS.h old_sequenceC.h old_sequenceS_T.h old_sequenceS.cpp old_sequenceC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_sequenceC.inl old_sequenceS_T.cpp old_sequenceS.h old_sequenceC.h old_sequenceS_T.h old_sequenceS.cpp old_sequenceC.cpp: old_sequence.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_sequence.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_sequenceC.inl old_sequenceS_T.cpp old_sequenceS.h old_sequenceC.h old_sequenceS_T.h old_sequenceS.cpp old_sequenceC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_structC.inl old_structS_T.cpp old_structS.h old_structC.h old_structS_T.h old_structS.cpp old_structC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_struct.idl" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_structC.inl old_structS_T.cpp old_structS.h old_structC.h old_structS_T.h old_structS.cpp old_structC.cpp: old_struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_structC.inl old_structS_T.cpp old_structS.h old_structC.h old_structS_T.h old_structS.cpp old_structC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_unionC.inl old_unionS_T.cpp old_unionS.h old_unionC.h old_unionS_T.h old_unionS.cpp old_unionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_union.idl" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_unionC.inl old_unionS_T.cpp old_unionS.h old_unionC.h old_unionS_T.h old_unionS.cpp old_unionC.cpp: old_union.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_union.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_unionC.inl old_unionS_T.cpp old_unionS.h old_unionC.h old_unionS_T.h old_unionS.cpp old_unionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_union2C.inl old_union2S_T.cpp old_union2S.h old_union2C.h old_union2S_T.h old_union2S.cpp old_union2C.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_union2.idl" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_union2C.inl old_union2S_T.cpp old_union2S.h old_union2C.h old_union2S_T.h old_union2S.cpp old_union2C.cpp: old_union2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_union2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_union2C.inl old_union2S_T.cpp old_union2S.h old_union2C.h old_union2S_T.h old_union2S.cpp old_union2C.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += paramsC.inl paramsS_T.cpp paramsS.h paramsC.h paramsS_T.h paramsS.cpp paramsC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "params.idl" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
paramsC.inl paramsS_T.cpp paramsS.h paramsC.h paramsS_T.h paramsS.cpp paramsC.cpp: params.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd params.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
paramsC.inl paramsS_T.cpp paramsS.h paramsC.h paramsS_T.h paramsS.cpp paramsC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopened_modulesC.inl reopened_modulesS_T.cpp reopened_modulesS.h reopened_modulesC.h reopened_modulesS_T.h reopened_modulesS.cpp reopened_modulesC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopened_modulesC.inl reopened_modulesS_T.cpp reopened_modulesS.h reopened_modulesC.h reopened_modulesS_T.h reopened_modulesS.cpp reopened_modulesC.cpp: reopened_modules.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd reopened_modules.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopened_modulesC.inl reopened_modulesS_T.cpp reopened_modulesS.h reopened_modulesC.h reopened_modulesS_T.h reopened_modulesS.cpp reopened_modulesC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += sequenceC.inl sequenceS_T.cpp sequenceS.h sequenceC.h sequenceS_T.h sequenceS.cpp sequenceC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "sequence.idl" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
sequenceC.inl sequenceS_T.cpp sequenceS.h sequenceC.h sequenceS_T.h sequenceS.cpp sequenceC.cpp: sequence.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd sequence.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
sequenceC.inl sequenceS_T.cpp sequenceS.h sequenceC.h sequenceS_T.h sequenceS.cpp sequenceC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += structC.inl structS_T.cpp structS.h structC.h structS_T.h structS.cpp structC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "struct.idl" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
structC.inl structS_T.cpp structS.h structC.h structS_T.h structS.cpp structC.cpp: struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
structC.inl structS_T.cpp structS.h structC.h structS_T.h structS.cpp structC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += string_valueC.inl string_valueS_T.cpp string_valueS.h string_valueC.h string_valueS_T.h string_valueS.cpp string_valueC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "string_value.idl" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS_T.h" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
string_valueC.inl string_valueS_T.cpp string_valueS.h string_valueC.h string_valueS_T.h string_valueS.cpp string_valueC.cpp: string_value.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd string_value.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
string_valueC.inl string_valueS_T.cpp string_valueS.h string_valueC.h string_valueS_T.h string_valueS.cpp string_valueC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopen_include1C.inl reopen_include1S_T.cpp reopen_include1S.h reopen_include1C.h reopen_include1S_T.h reopen_include1S.cpp reopen_include1C.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopen_include1C.inl reopen_include1S_T.cpp reopen_include1S.h reopen_include1C.h reopen_include1S_T.h reopen_include1S.cpp reopen_include1C.cpp: reopen_include1.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd reopen_include1.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopen_include1C.inl reopen_include1S_T.cpp reopen_include1S.h reopen_include1C.h reopen_include1S_T.h reopen_include1S.cpp reopen_include1C.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopen_include2C.inl reopen_include2S_T.cpp reopen_include2S.h reopen_include2C.h reopen_include2S_T.h reopen_include2S.cpp reopen_include2C.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopen_include2C.inl reopen_include2S_T.cpp reopen_include2S.h reopen_include2C.h reopen_include2S_T.h reopen_include2S.cpp reopen_include2C.cpp: reopen_include2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd reopen_include2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopen_include2C.inl reopen_include2S_T.cpp reopen_include2S.h reopen_include2C.h reopen_include2S_T.h reopen_include2S.cpp reopen_include2C.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typeprefixC.inl typeprefixS_T.cpp typeprefixS.h typeprefixC.h typeprefixS_T.h typeprefixS.cpp typeprefixC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typeprefixC.inl typeprefixS_T.cpp typeprefixS.h typeprefixC.h typeprefixS_T.h typeprefixS.cpp typeprefixC.cpp: typeprefix.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd typeprefix.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typeprefixC.inl typeprefixS_T.cpp typeprefixS.h typeprefixC.h typeprefixS_T.h typeprefixS.cpp typeprefixC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += unionC.inl unionS_T.cpp unionS.h unionC.h unionS_T.h unionS.cpp unionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "union.idl" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
unionC.inl unionS_T.cpp unionS.h unionC.h unionS_T.h unionS.cpp unionC.cpp: union.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd union.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
unionC.inl unionS_T.cpp unionS.h unionC.h unionS_T.h unionS.cpp unionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += enum_in_structC.inl enum_in_structS_T.cpp enum_in_structS.h enum_in_structC.h enum_in_structS_T.h enum_in_structS.cpp enum_in_structC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
enum_in_structC.inl enum_in_structS_T.cpp enum_in_structS.h enum_in_structC.h enum_in_structS_T.h enum_in_structS.cpp enum_in_structC.cpp: enum_in_struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as enum_in_struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
enum_in_structC.inl enum_in_structS_T.cpp enum_in_structS.h enum_in_structC.h enum_in_structS_T.h enum_in_structS.cpp enum_in_structC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_anonymousC.inl array_anonymousS_T.cpp array_anonymousS.h array_anonymousC.h array_anonymousS_T.h array_anonymousS.cpp array_anonymousC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousS.h" 2> /dev/null || $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousC.h" 2> /dev/null || $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "array_anonymous.idl" -nt "array_anonymousC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anonymousC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_anonymousC.inl array_anonymousS_T.cpp array_anonymousS.h array_anonymousC.h array_anonymousS_T.h array_anonymousS.cpp array_anonymousC.cpp: array_anonymous.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as array_anonymous.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_anonymousC.inl array_anonymousS_T.cpp array_anonymousS.h array_anonymousC.h array_anonymousS_T.h array_anonymousS.cpp array_anonymousC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_anon_nestedC.inl array_anon_nestedS_T.cpp array_anon_nestedS.h array_anon_nestedC.h array_anon_nestedS_T.h array_anon_nestedS.cpp array_anon_nestedC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_anon_nestedC.inl array_anon_nestedS_T.cpp array_anon_nestedS.h array_anon_nestedC.h array_anon_nestedS_T.h array_anon_nestedS.cpp array_anon_nestedC.cpp: array_anon_nested.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as array_anon_nested.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_anon_nestedC.inl array_anon_nestedS_T.cpp array_anon_nestedS.h array_anon_nestedC.h array_anon_nestedS_T.h array_anon_nestedS.cpp array_anon_nestedC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += includedC.inl includedS_T.cpp includedS.h includedC.h includedS_T.h includedS.cpp includedC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "included.idl" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
includedC.inl includedS_T.cpp includedS.h includedC.h includedS_T.h includedS.cpp includedC.cpp: included.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as included.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
includedC.inl includedS_T.cpp includedS.h includedC.h includedS_T.h includedS.cpp includedC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += includingC.inl includingS_T.cpp includingS.h includingC.h includingS_T.h includingS.cpp includingC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "including.idl" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
includingC.inl includingS_T.cpp includingS.h includingC.h includingS_T.h includingS.cpp includingC.cpp: including.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as including.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
includingC.inl includingS_T.cpp includingS.h includingC.h includingS_T.h includingS.cpp includingC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += sequence_anonymousC.inl sequence_anonymousS_T.cpp sequence_anonymousS.h sequence_anonymousC.h sequence_anonymousS_T.h sequence_anonymousS.cpp sequence_anonymousC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousS.h" 2> /dev/null || $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousC.h" 2> /dev/null || $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "sequence_anonymous.idl" -nt "sequence_anonymousC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequence_anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequence_anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequence_anonymousC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
sequence_anonymousC.inl sequence_anonymousS_T.cpp sequence_anonymousS.h sequence_anonymousC.h sequence_anonymousS_T.h sequence_anonymousS.cpp sequence_anonymousC.cpp: sequence_anonymous.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as sequence_anonymous.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
sequence_anonymousC.inl sequence_anonymousS_T.cpp sequence_anonymousS.h sequence_anonymousC.h sequence_anonymousS_T.h sequence_anonymousS.cpp sequence_anonymousC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += union_anonymousC.inl union_anonymousS_T.cpp union_anonymousS.h union_anonymousC.h union_anonymousS_T.h union_anonymousS.cpp union_anonymousC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousS.h" 2> /dev/null || $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousC.h" 2> /dev/null || $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "union_anonymous.idl" -nt "union_anonymousC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "union_anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "union_anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "union_anonymousC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
union_anonymousC.inl union_anonymousS_T.cpp union_anonymousS.h union_anonymousC.h union_anonymousS_T.h union_anonymousS.cpp union_anonymousC.cpp: union_anonymous.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as union_anonymous.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
union_anonymousC.inl union_anonymousS_T.cpp union_anonymousS.h union_anonymousC.h union_anonymousS_T.h union_anonymousS.cpp union_anonymousC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += anyunionC.inl anyunionS_T.cpp anyunionS.h anyunionC.h anyunionS_T.h anyunionS.cpp anyunionC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "anyunion.idl" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
anyunionC.inl anyunionS_T.cpp anyunionS.h anyunionC.h anyunionS_T.h anyunionS.cpp anyunionC.cpp: anyunion.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as anyunion.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
anyunionC.inl anyunionS_T.cpp anyunionS.h anyunionC.h anyunionS_T.h anyunionS.cpp anyunionC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += valuetypeC.inl valuetypeS_T.cpp valuetypeS.h valuetypeC.h valuetypeS_T.h valuetypeS.cpp valuetypeC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
valuetypeC.inl valuetypeS_T.cpp valuetypeS.h valuetypeC.h valuetypeS_T.h valuetypeS.cpp valuetypeC.cpp: valuetype.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as valuetype.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
valuetypeC.inl valuetypeS_T.cpp valuetypeS.h valuetypeC.h valuetypeS_T.h valuetypeS.cpp valuetypeC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += anonymousC.inl anonymousS_T.cpp anonymousS.h anonymousA.h anonymousC.h anonymousS_T.h anonymousS.cpp anonymousC.cpp anonymousA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "anonymous.idl" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
anonymousC.inl anonymousS_T.cpp anonymousS.h anonymousA.h anonymousC.h anonymousS_T.h anonymousS.cpp anonymousC.cpp anonymousA.cpp: anonymous.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as anonymous.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
anonymousC.inl anonymousS_T.cpp anonymousS.h anonymousA.h anonymousC.h anonymousS_T.h anonymousS.cpp anonymousC.cpp anonymousA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += dif2C.inl dif2S_T.cpp dif2S.h dif2A.h dif2C.h dif2S_T.h dif2S.cpp dif2C.cpp dif2A.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "dif2.idl" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2A.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2A.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
dif2C.inl dif2S_T.cpp dif2S.h dif2A.h dif2C.h dif2S_T.h dif2S.cpp dif2C.cpp dif2A.cpp: dif2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as dif2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
dif2C.inl dif2S_T.cpp dif2S.h dif2A.h dif2C.h dif2S_T.h dif2S.cpp dif2C.cpp dif2A.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_onlyC.inl array_onlyS_T.cpp array_onlyS.h array_onlyA.h array_onlyC.h array_onlyS_T.h array_onlyS.cpp array_onlyC.cpp array_onlyA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_only.idl" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_onlyC.inl array_onlyS_T.cpp array_onlyS.h array_onlyA.h array_onlyC.h array_onlyS_T.h array_onlyS.cpp array_onlyC.cpp array_onlyA.cpp: array_only.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA array_only.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_onlyC.inl array_onlyS_T.cpp array_onlyS.h array_onlyA.h array_onlyC.h array_onlyS_T.h array_onlyS.cpp array_onlyC.cpp array_onlyA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += constantsC.inl constantsS_T.cpp constantsS.h constantsA.h constantsC.h constantsS_T.h constantsS.cpp constantsC.cpp constantsA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "constants.idl" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
constantsC.inl constantsS_T.cpp constantsS.h constantsA.h constantsC.h constantsS_T.h constantsS.cpp constantsC.cpp constantsA.cpp: constants.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA constants.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
constantsC.inl constantsS_T.cpp constantsS.h constantsA.h constantsC.h constantsS_T.h constantsS.cpp constantsC.cpp constantsA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += generic_objectC.inl generic_objectS_T.cpp generic_objectS.h generic_objectA.h generic_objectC.h generic_objectS_T.h generic_objectS.cpp generic_objectC.cpp generic_objectA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
generic_objectC.inl generic_objectS_T.cpp generic_objectS.h generic_objectA.h generic_objectC.h generic_objectS_T.h generic_objectS.cpp generic_objectC.cpp generic_objectA.cpp: generic_object.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA generic_object.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
generic_objectC.inl generic_objectS_T.cpp generic_objectS.h generic_objectA.h generic_objectC.h generic_objectS_T.h generic_objectS.cpp generic_objectC.cpp generic_objectA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += inheritC.inl inheritS_T.cpp inheritS.h inheritA.h inheritC.h inheritS_T.h inheritS.cpp inheritC.cpp inheritA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "inherit.idl" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
inheritC.inl inheritS_T.cpp inheritS.h inheritA.h inheritC.h inheritS_T.h inheritS.cpp inheritC.cpp inheritA.cpp: inherit.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA inherit.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
inheritC.inl inheritS_T.cpp inheritS.h inheritA.h inheritC.h inheritS_T.h inheritS.cpp inheritC.cpp inheritA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += moduleC.inl moduleS_T.cpp moduleS.h moduleA.h moduleC.h moduleS_T.h moduleS.cpp moduleC.cpp moduleA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "module.idl" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
moduleC.inl moduleS_T.cpp moduleS.h moduleA.h moduleC.h moduleS_T.h moduleS.cpp moduleC.cpp moduleA.cpp: module.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA module.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
moduleC.inl moduleS_T.cpp moduleS.h moduleA.h moduleC.h moduleS_T.h moduleS.cpp moduleC.cpp moduleA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += primtypesC.inl primtypesS_T.cpp primtypesS.h primtypesA.h primtypesC.h primtypesS_T.h primtypesS.cpp primtypesC.cpp primtypesA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "primtypes.idl" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
primtypesC.inl primtypesS_T.cpp primtypesS.h primtypesA.h primtypesC.h primtypesS_T.h primtypesS.cpp primtypesC.cpp primtypesA.cpp: primtypes.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA primtypes.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
primtypesC.inl primtypesS_T.cpp primtypesS.h primtypesA.h primtypesC.h primtypesS_T.h primtypesS.cpp primtypesC.cpp primtypesA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += pragmaC.inl pragmaS_T.cpp pragmaS.h pragmaA.h pragmaC.h pragmaS_T.h pragmaS.cpp pragmaC.cpp pragmaA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "pragma.idl" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
pragmaC.inl pragmaS_T.cpp pragmaS.h pragmaA.h pragmaC.h pragmaS_T.h pragmaS.cpp pragmaC.cpp pragmaA.cpp: pragma.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA pragma.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
pragmaC.inl pragmaS_T.cpp pragmaS.h pragmaA.h pragmaC.h pragmaS_T.h pragmaS.cpp pragmaC.cpp pragmaA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += repo_id_modC.inl repo_id_modS_T.cpp repo_id_modS.h repo_id_modA.h repo_id_modC.h repo_id_modS_T.h repo_id_modS.cpp repo_id_modC.cpp repo_id_modA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
repo_id_modC.inl repo_id_modS_T.cpp repo_id_modS.h repo_id_modA.h repo_id_modC.h repo_id_modS_T.h repo_id_modS.cpp repo_id_modC.cpp repo_id_modA.cpp: repo_id_mod.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA repo_id_mod.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
repo_id_modC.inl repo_id_modS_T.cpp repo_id_modS.h repo_id_modA.h repo_id_modC.h repo_id_modS_T.h repo_id_modS.cpp repo_id_modC.cpp repo_id_modA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typedefC.inl typedefS_T.cpp typedefS.h typedefA.h typedefC.h typedefS_T.h typedefS.cpp typedefC.cpp typedefA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typedef.idl" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typedefC.inl typedefS_T.cpp typedefS.h typedefA.h typedefC.h typedefS_T.h typedefS.cpp typedefC.cpp typedefA.cpp: typedef.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA typedef.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typedefC.inl typedefS_T.cpp typedefS.h typedefA.h typedefC.h typedefS_T.h typedefS.cpp typedefC.cpp typedefA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typecodeC.inl typecodeS_T.cpp typecodeS.h typecodeA.h typecodeC.h typecodeS_T.h typecodeS.cpp typecodeC.cpp typecodeA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typecode.idl" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typecodeC.inl typecodeS_T.cpp typecodeS.h typecodeA.h typecodeC.h typecodeS_T.h typecodeS.cpp typecodeC.cpp typecodeA.cpp: typecode.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA typecode.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typecodeC.inl typecodeS_T.cpp typecodeS.h typecodeA.h typecodeC.h typecodeS_T.h typecodeS.cpp typecodeC.cpp typecodeA.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PEMNamingC.inl PEMNamingS_T.cpp PEMNamingS.h PEMNamingC.h PEMNamingS_T.h PEMNamingS.cpp PEMNamingC.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS_T.h" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingC.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingC.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PEMNamingC.inl PEMNamingS_T.cpp PEMNamingS.h PEMNamingC.h PEMNamingS_T.h PEMNamingS.cpp PEMNamingC.cpp: PEMNaming.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd loader_const.idl PEMNaming.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PEMNamingC.inl PEMNamingS_T.cpp PEMNamingS.h PEMNamingC.h PEMNamingS_T.h PEMNamingS.cpp PEMNamingC.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

ifneq ($(GENERATED_DIRTY),)
.PRECIOUS: $(GENERATED_DIRTY)
ifeq ($(corba_messaging),1)
all: $(GENERATED_DIRTY)
endif
endif

ADDITIONAL_IDL_TARGETS += $(GENERATED_DIRTY)
idl_stubs: $(ADDITIONAL_IDL_TARGETS)

incremental_depend_idl::
	@$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old
	@cp $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE1) \
	$(IDL_DEPS_FLAGS1) -t gnuidl -DMAKEDEPEND $(IDL_DEPS1)
	@if cmp -s $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS1)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS1)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old
	@cp $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE2) \
	$(IDL_DEPS_FLAGS2) -t gnuidl -DMAKEDEPEND $(IDL_DEPS2)
	@if cmp -s $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS2)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS2)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old
	@cp $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE3) \
	$(IDL_DEPS_FLAGS3) -t gnuidl -DMAKEDEPEND $(IDL_DEPS3)
	@if cmp -s $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS3)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS3)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old
	@cp $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE4) \
	$(IDL_DEPS_FLAGS4) -t gnuidl -DMAKEDEPEND $(IDL_DEPS4)
	@if cmp -s $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS4)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS4)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old
	@cp $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE5) \
	$(IDL_DEPS_FLAGS5) -t gnuidl -DMAKEDEPEND $(IDL_DEPS5)
	@if cmp -s $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS5)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS5)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old
	@cp $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE6) \
	$(IDL_DEPS_FLAGS6) -t gnuidl -DMAKEDEPEND $(IDL_DEPS6)
	@if cmp -s $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS6)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS6)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old
	@cp $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE7) \
	$(IDL_DEPS_FLAGS7) -t gnuidl -DMAKEDEPEND $(IDL_DEPS7)
	@if cmp -s $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS7)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS7)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old
	@cp $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE8) \
	$(IDL_DEPS_FLAGS8) -t gnuidl -DMAKEDEPEND $(IDL_DEPS8)
	@if cmp -s $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS8)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS8)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old
	@cp $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE9) \
	$(IDL_DEPS_FLAGS9) -t gnuidl -DMAKEDEPEND $(IDL_DEPS9)
	@if cmp -s $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS9)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS9)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old
	@cp $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE10) \
	$(IDL_DEPS_FLAGS10) -t gnuidl -DMAKEDEPEND $(IDL_DEPS10)
	@if cmp -s $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS10)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS10)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old
	@cp $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE11) \
	$(IDL_DEPS_FLAGS11) -t gnuidl -DMAKEDEPEND $(IDL_DEPS11)
	@if cmp -s $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS11)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS11)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old
	@cp $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE12) \
	$(IDL_DEPS_FLAGS12) -t gnuidl -DMAKEDEPEND $(IDL_DEPS12)
	@if cmp -s $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS12)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS12)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old
	@cp $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE13) \
	$(IDL_DEPS_FLAGS13) -t gnuidl -DMAKEDEPEND $(IDL_DEPS13)
	@if cmp -s $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS13)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS13)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old
	@cp $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE14) \
	$(IDL_DEPS_FLAGS14) -t gnuidl -DMAKEDEPEND $(IDL_DEPS14)
	@if cmp -s $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS14)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS14)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old
	@cp $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE15) \
	$(IDL_DEPS_FLAGS15) -t gnuidl -DMAKEDEPEND $(IDL_DEPS15)
	@if cmp -s $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS15)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS15)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old
	@cp $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE16) \
	$(IDL_DEPS_FLAGS16) -t gnuidl -DMAKEDEPEND $(IDL_DEPS16)
	@if cmp -s $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS16)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS16)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE17)_idl.old
	@cp $(IDL_DEPENDENCY_FILE17) $(IDL_DEPENDENCY_FILE17)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE17) \
	$(IDL_DEPS_FLAGS17) -t gnuidl -DMAKEDEPEND $(IDL_DEPS17)
	@if cmp -s $(IDL_DEPENDENCY_FILE17) $(IDL_DEPENDENCY_FILE17)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS17)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS17)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE17)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE18)_idl.old
	@cp $(IDL_DEPENDENCY_FILE18) $(IDL_DEPENDENCY_FILE18)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE18) \
	$(IDL_DEPS_FLAGS18) -t gnuidl -DMAKEDEPEND $(IDL_DEPS18)
	@if cmp -s $(IDL_DEPENDENCY_FILE18) $(IDL_DEPENDENCY_FILE18)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS18)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS18)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE18)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE19)_idl.old
	@cp $(IDL_DEPENDENCY_FILE19) $(IDL_DEPENDENCY_FILE19)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE19) \
	$(IDL_DEPS_FLAGS19) -t gnuidl -DMAKEDEPEND $(IDL_DEPS19)
	@if cmp -s $(IDL_DEPENDENCY_FILE19) $(IDL_DEPENDENCY_FILE19)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS19)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS19)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE19)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE20)_idl.old
	@cp $(IDL_DEPENDENCY_FILE20) $(IDL_DEPENDENCY_FILE20)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE20) \
	$(IDL_DEPS_FLAGS20) -t gnuidl -DMAKEDEPEND $(IDL_DEPS20)
	@if cmp -s $(IDL_DEPENDENCY_FILE20) $(IDL_DEPENDENCY_FILE20)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS20)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS20)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE20)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE21)_idl.old
	@cp $(IDL_DEPENDENCY_FILE21) $(IDL_DEPENDENCY_FILE21)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE21) \
	$(IDL_DEPS_FLAGS21) -t gnuidl -DMAKEDEPEND $(IDL_DEPS21)
	@if cmp -s $(IDL_DEPENDENCY_FILE21) $(IDL_DEPENDENCY_FILE21)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS21)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS21)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE21)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE22)_idl.old
	@cp $(IDL_DEPENDENCY_FILE22) $(IDL_DEPENDENCY_FILE22)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE22) \
	$(IDL_DEPS_FLAGS22) -t gnuidl -DMAKEDEPEND $(IDL_DEPS22)
	@if cmp -s $(IDL_DEPENDENCY_FILE22) $(IDL_DEPENDENCY_FILE22)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS22)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS22)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE22)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE23)_idl.old
	@cp $(IDL_DEPENDENCY_FILE23) $(IDL_DEPENDENCY_FILE23)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE23) \
	$(IDL_DEPS_FLAGS23) -t gnuidl -DMAKEDEPEND $(IDL_DEPS23)
	@if cmp -s $(IDL_DEPENDENCY_FILE23) $(IDL_DEPENDENCY_FILE23)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS23)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS23)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE23)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE24)_idl.old
	@cp $(IDL_DEPENDENCY_FILE24) $(IDL_DEPENDENCY_FILE24)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE24) \
	$(IDL_DEPS_FLAGS24) -t gnuidl -DMAKEDEPEND $(IDL_DEPS24)
	@if cmp -s $(IDL_DEPENDENCY_FILE24) $(IDL_DEPENDENCY_FILE24)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS24)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS24)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE24)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE25)_idl.old
	@cp $(IDL_DEPENDENCY_FILE25) $(IDL_DEPENDENCY_FILE25)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE25) \
	$(IDL_DEPS_FLAGS25) -t gnuidl -DMAKEDEPEND $(IDL_DEPS25)
	@if cmp -s $(IDL_DEPENDENCY_FILE25) $(IDL_DEPENDENCY_FILE25)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS25)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS25)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE25)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE26)_idl.old
	@cp $(IDL_DEPENDENCY_FILE26) $(IDL_DEPENDENCY_FILE26)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE26) \
	$(IDL_DEPS_FLAGS26) -t gnuidl -DMAKEDEPEND $(IDL_DEPS26)
	@if cmp -s $(IDL_DEPENDENCY_FILE26) $(IDL_DEPENDENCY_FILE26)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS26)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS26)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE26)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE27)_idl.old
	@cp $(IDL_DEPENDENCY_FILE27) $(IDL_DEPENDENCY_FILE27)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE27) \
	$(IDL_DEPS_FLAGS27) -t gnuidl -DMAKEDEPEND $(IDL_DEPS27)
	@if cmp -s $(IDL_DEPENDENCY_FILE27) $(IDL_DEPENDENCY_FILE27)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS27)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS27)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE27)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE28)_idl.old
	@cp $(IDL_DEPENDENCY_FILE28) $(IDL_DEPENDENCY_FILE28)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE28) \
	$(IDL_DEPS_FLAGS28) -t gnuidl -DMAKEDEPEND $(IDL_DEPS28)
	@if cmp -s $(IDL_DEPENDENCY_FILE28) $(IDL_DEPENDENCY_FILE28)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS28)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS28)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE28)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE29)_idl.old
	@cp $(IDL_DEPENDENCY_FILE29) $(IDL_DEPENDENCY_FILE29)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE29) \
	$(IDL_DEPS_FLAGS29) -t gnuidl -DMAKEDEPEND $(IDL_DEPS29)
	@if cmp -s $(IDL_DEPENDENCY_FILE29) $(IDL_DEPENDENCY_FILE29)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS29)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS29)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE29)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE30)_idl.old
	@cp $(IDL_DEPENDENCY_FILE30) $(IDL_DEPENDENCY_FILE30)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE30) \
	$(IDL_DEPS_FLAGS30) -t gnuidl -DMAKEDEPEND $(IDL_DEPS30)
	@if cmp -s $(IDL_DEPENDENCY_FILE30) $(IDL_DEPENDENCY_FILE30)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS30)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS30)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE30)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE31)_idl.old
	@cp $(IDL_DEPENDENCY_FILE31) $(IDL_DEPENDENCY_FILE31)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE31) \
	$(IDL_DEPS_FLAGS31) -t gnuidl -DMAKEDEPEND $(IDL_DEPS31)
	@if cmp -s $(IDL_DEPENDENCY_FILE31) $(IDL_DEPENDENCY_FILE31)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS31)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS31)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE31)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE32)_idl.old
	@cp $(IDL_DEPENDENCY_FILE32) $(IDL_DEPENDENCY_FILE32)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE32) \
	$(IDL_DEPS_FLAGS32) -t gnuidl -DMAKEDEPEND $(IDL_DEPS32)
	@if cmp -s $(IDL_DEPENDENCY_FILE32) $(IDL_DEPENDENCY_FILE32)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS32)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS32)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE32)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE33)_idl.old
	@cp $(IDL_DEPENDENCY_FILE33) $(IDL_DEPENDENCY_FILE33)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE33) \
	$(IDL_DEPS_FLAGS33) -t gnuidl -DMAKEDEPEND $(IDL_DEPS33)
	@if cmp -s $(IDL_DEPENDENCY_FILE33) $(IDL_DEPENDENCY_FILE33)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS33)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS33)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE33)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE34)_idl.old
	@cp $(IDL_DEPENDENCY_FILE34) $(IDL_DEPENDENCY_FILE34)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE34) \
	$(IDL_DEPS_FLAGS34) -t gnuidl -DMAKEDEPEND $(IDL_DEPS34)
	@if cmp -s $(IDL_DEPENDENCY_FILE34) $(IDL_DEPENDENCY_FILE34)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS34)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS34)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE34)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE35)_idl.old
	@cp $(IDL_DEPENDENCY_FILE35) $(IDL_DEPENDENCY_FILE35)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE35) \
	$(IDL_DEPS_FLAGS35) -t gnuidl -DMAKEDEPEND $(IDL_DEPS35)
	@if cmp -s $(IDL_DEPENDENCY_FILE35) $(IDL_DEPENDENCY_FILE35)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS35)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS35)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE35)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE36)_idl.old
	@cp $(IDL_DEPENDENCY_FILE36) $(IDL_DEPENDENCY_FILE36)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE36) \
	$(IDL_DEPS_FLAGS36) -t gnuidl -DMAKEDEPEND $(IDL_DEPS36)
	@if cmp -s $(IDL_DEPENDENCY_FILE36) $(IDL_DEPENDENCY_FILE36)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS36)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS36)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE36)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE37)_idl.old
	@cp $(IDL_DEPENDENCY_FILE37) $(IDL_DEPENDENCY_FILE37)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE37) \
	$(IDL_DEPS_FLAGS37) -t gnuidl -DMAKEDEPEND $(IDL_DEPS37)
	@if cmp -s $(IDL_DEPENDENCY_FILE37) $(IDL_DEPENDENCY_FILE37)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS37)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS37)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE37)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE38)_idl.old
	@cp $(IDL_DEPENDENCY_FILE38) $(IDL_DEPENDENCY_FILE38)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE38) \
	$(IDL_DEPS_FLAGS38) -t gnuidl -DMAKEDEPEND $(IDL_DEPS38)
	@if cmp -s $(IDL_DEPENDENCY_FILE38) $(IDL_DEPENDENCY_FILE38)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS38)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS38)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE38)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE39)_idl.old
	@cp $(IDL_DEPENDENCY_FILE39) $(IDL_DEPENDENCY_FILE39)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE39) \
	$(IDL_DEPS_FLAGS39) -t gnuidl -DMAKEDEPEND $(IDL_DEPS39)
	@if cmp -s $(IDL_DEPENDENCY_FILE39) $(IDL_DEPENDENCY_FILE39)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS39)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS39)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE39)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE40)_idl.old
	@cp $(IDL_DEPENDENCY_FILE40) $(IDL_DEPENDENCY_FILE40)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE40) \
	$(IDL_DEPS_FLAGS40) -t gnuidl -DMAKEDEPEND $(IDL_DEPS40)
	@if cmp -s $(IDL_DEPENDENCY_FILE40) $(IDL_DEPENDENCY_FILE40)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS40)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS40)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE40)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE41)_idl.old
	@cp $(IDL_DEPENDENCY_FILE41) $(IDL_DEPENDENCY_FILE41)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE41) \
	$(IDL_DEPS_FLAGS41) -t gnuidl -DMAKEDEPEND $(IDL_DEPS41)
	@if cmp -s $(IDL_DEPENDENCY_FILE41) $(IDL_DEPENDENCY_FILE41)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS41)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS41)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE41)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE42)_idl.old
	@cp $(IDL_DEPENDENCY_FILE42) $(IDL_DEPENDENCY_FILE42)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE42) \
	$(IDL_DEPS_FLAGS42) -t gnuidl -DMAKEDEPEND $(IDL_DEPS42)
	@if cmp -s $(IDL_DEPENDENCY_FILE42) $(IDL_DEPENDENCY_FILE42)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS42)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS42)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE42)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE43)_idl.old
	@cp $(IDL_DEPENDENCY_FILE43) $(IDL_DEPENDENCY_FILE43)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE43) \
	$(IDL_DEPS_FLAGS43) -t gnuidl -DMAKEDEPEND $(IDL_DEPS43)
	@if cmp -s $(IDL_DEPENDENCY_FILE43) $(IDL_DEPENDENCY_FILE43)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS43)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS43)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE43)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE44)_idl.old
	@cp $(IDL_DEPENDENCY_FILE44) $(IDL_DEPENDENCY_FILE44)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE44) \
	$(IDL_DEPS_FLAGS44) -t gnuidl -DMAKEDEPEND $(IDL_DEPS44)
	@if cmp -s $(IDL_DEPENDENCY_FILE44) $(IDL_DEPENDENCY_FILE44)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS44)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS44)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE44)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE45)_idl.old
	@cp $(IDL_DEPENDENCY_FILE45) $(IDL_DEPENDENCY_FILE45)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE45) \
	$(IDL_DEPS_FLAGS45) -t gnuidl -DMAKEDEPEND $(IDL_DEPS45)
	@if cmp -s $(IDL_DEPENDENCY_FILE45) $(IDL_DEPENDENCY_FILE45)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS45)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS45)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE45)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE46)_idl.old
	@cp $(IDL_DEPENDENCY_FILE46) $(IDL_DEPENDENCY_FILE46)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE46) \
	$(IDL_DEPS_FLAGS46) -t gnuidl -DMAKEDEPEND $(IDL_DEPS46)
	@if cmp -s $(IDL_DEPENDENCY_FILE46) $(IDL_DEPENDENCY_FILE46)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS46)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS46)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE46)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE47)_idl.old
	@cp $(IDL_DEPENDENCY_FILE47) $(IDL_DEPENDENCY_FILE47)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE47) \
	$(IDL_DEPS_FLAGS47) -t gnuidl -DMAKEDEPEND $(IDL_DEPS47)
	@if cmp -s $(IDL_DEPENDENCY_FILE47) $(IDL_DEPENDENCY_FILE47)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS47)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS47)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE47)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE48)_idl.old
	@cp $(IDL_DEPENDENCY_FILE48) $(IDL_DEPENDENCY_FILE48)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE48) \
	$(IDL_DEPS_FLAGS48) -t gnuidl -DMAKEDEPEND $(IDL_DEPS48)
	@if cmp -s $(IDL_DEPENDENCY_FILE48) $(IDL_DEPENDENCY_FILE48)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS48)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS48)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE48)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE49)_idl.old
	@cp $(IDL_DEPENDENCY_FILE49) $(IDL_DEPENDENCY_FILE49)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE49) \
	$(IDL_DEPS_FLAGS49) -t gnuidl -DMAKEDEPEND $(IDL_DEPS49)
	@if cmp -s $(IDL_DEPENDENCY_FILE49) $(IDL_DEPENDENCY_FILE49)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS49)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS49)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE49)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE50)_idl.old
	@cp $(IDL_DEPENDENCY_FILE50) $(IDL_DEPENDENCY_FILE50)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE50) \
	$(IDL_DEPS_FLAGS50) -t gnuidl -DMAKEDEPEND $(IDL_DEPS50)
	@if cmp -s $(IDL_DEPENDENCY_FILE50) $(IDL_DEPENDENCY_FILE50)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS50)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS50)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE50)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE51)_idl.old
	@cp $(IDL_DEPENDENCY_FILE51) $(IDL_DEPENDENCY_FILE51)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE51) \
	$(IDL_DEPS_FLAGS51) -t gnuidl -DMAKEDEPEND $(IDL_DEPS51)
	@if cmp -s $(IDL_DEPENDENCY_FILE51) $(IDL_DEPENDENCY_FILE51)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS51)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS51)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE51)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE52)_idl.old
	@cp $(IDL_DEPENDENCY_FILE52) $(IDL_DEPENDENCY_FILE52)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE52) \
	$(IDL_DEPS_FLAGS52) -t gnuidl -DMAKEDEPEND $(IDL_DEPS52)
	@if cmp -s $(IDL_DEPENDENCY_FILE52) $(IDL_DEPENDENCY_FILE52)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS52)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS52)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE52)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE53)_idl.old
	@cp $(IDL_DEPENDENCY_FILE53) $(IDL_DEPENDENCY_FILE53)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE53) \
	$(IDL_DEPS_FLAGS53) -t gnuidl -DMAKEDEPEND $(IDL_DEPS53)
	@if cmp -s $(IDL_DEPENDENCY_FILE53) $(IDL_DEPENDENCY_FILE53)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS53)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS53)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE53)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE54)_idl.old
	@cp $(IDL_DEPENDENCY_FILE54) $(IDL_DEPENDENCY_FILE54)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE54) \
	$(IDL_DEPS_FLAGS54) -t gnuidl -DMAKEDEPEND $(IDL_DEPS54)
	@if cmp -s $(IDL_DEPENDENCY_FILE54) $(IDL_DEPENDENCY_FILE54)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS54)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS54)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE54)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE55)_idl.old
	@cp $(IDL_DEPENDENCY_FILE55) $(IDL_DEPENDENCY_FILE55)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE55) \
	$(IDL_DEPS_FLAGS55) -t gnuidl -DMAKEDEPEND $(IDL_DEPS55)
	@if cmp -s $(IDL_DEPENDENCY_FILE55) $(IDL_DEPENDENCY_FILE55)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS55)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS55)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE55)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE56)_idl.old
	@cp $(IDL_DEPENDENCY_FILE56) $(IDL_DEPENDENCY_FILE56)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE56) \
	$(IDL_DEPS_FLAGS56) -t gnuidl -DMAKEDEPEND $(IDL_DEPS56)
	@if cmp -s $(IDL_DEPENDENCY_FILE56) $(IDL_DEPENDENCY_FILE56)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS56)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS56)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE56)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE57)_idl.old
	@cp $(IDL_DEPENDENCY_FILE57) $(IDL_DEPENDENCY_FILE57)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE57) \
	$(IDL_DEPS_FLAGS57) -t gnuidl -DMAKEDEPEND $(IDL_DEPS57)
	@if cmp -s $(IDL_DEPENDENCY_FILE57) $(IDL_DEPENDENCY_FILE57)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS57)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS57)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE57)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE58)_idl.old
	@cp $(IDL_DEPENDENCY_FILE58) $(IDL_DEPENDENCY_FILE58)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE58) \
	$(IDL_DEPS_FLAGS58) -t gnuidl -DMAKEDEPEND $(IDL_DEPS58)
	@if cmp -s $(IDL_DEPENDENCY_FILE58) $(IDL_DEPENDENCY_FILE58)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS58)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS58)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE58)_idl.old ;

realclean: clean
ifneq ($(GENERATED_DIRTY),)
	-$(RM) -r $(filter-out $(PRECIOUS_FILES),$(GENERATED_DIRTY))
endif

__prebuild__:
ifeq ($(corba_messaging),1)
	@-:
endif


.PHONY: install
install: all
INSTALL_LIB ?= lib
ifneq ($(INSTALL_PREFIX),)
ifneq ($(install_rpath),0)
LD_RPATH ?= -Wl,-rpath,
LDFLAGS += $(LD_RPATH)$(INSTALL_PREFIX)/$(INSTALL_LIB) $(LD_RPATH_FLAGS)
endif
endif


